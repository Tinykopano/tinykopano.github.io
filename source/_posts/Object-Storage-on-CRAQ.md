---
title: 'Object Storage on CRAQ: High-throughput chain replication for read-mostly workloads'
date: 2023-05-07 19:32:00 +0800
categories: [Course,Paper]
tags: [distributed system]
---

# CRAQ上的对象存储：针对大部分为读的工作负载的高吞吐量链式复制

## 摘要

大规模的存储系统通常在许多可能出现问题的组件上复制和划分数据，以提供可靠性和可扩展性。然而，许多商业部署的系统，特别是那些为客户交互使用而设计的系统，为了追求更高的可用性和更高的效率，牺牲了更强的一致性性，以获得更强的可用性和更高的吞吐量。

本文描述了CRAQ的设计、实现和评估，这是一个分布式对象存储系统，挑战这种不灵活的权衡。我们的基本方法是对链式复制的改进，在保持强大的一致性的同时，极大地提高了读取吞吐量。通过在所有对象复制中分配负载，CRAQ随着链的大小线性扩展而不增加一致性协调。同时，当未提交操作对某些应用来说已经足够时，它还会暴露出较弱的一致性保证，这在系统高速运转的时期特别有用。本文探讨了跨多个数据中心的地理复制CRAQ存储的额外设计和实现考虑，以提供本地优化的操作。我们还讨论了多对象原子更新和大对象更新的组播优化。

<!-- more -->

## 一、  引言

许多在线服务需要基于对象的存储，其中数据以整个单元的形式呈现给应用程序。对象存储支持两个基本的原语：读（或查询）操作返回存储在对象名称下的数据块，而写（或更新）操作改变单个对象的状态。这种基于对象的存储由键值数据库（如BerkeleyDB[40]或Apache的半结构化CouchDB[13]）到部署在商业数据中心的大规模可扩展系统（如Amazon的Dynamo[15]、Facebook的Cassandra[16]和流行的Memcached[18]）支持。为了在许多这样的系统中实现必要的可靠性、负载平衡和可扩展性，对象命名空间被分割到许多机器上，每个数据对象被复制了几次。

当应用程序有某些要求时，基于对象的系统比其文件系统的对应系统更有吸引力。对象存储更适合于平面名称空间，比如在键值数据库中，而不是分层的目录结构。对象存储简化了支持整个对象修改的过程。而且，它们通常只需要对特定对象的修改顺序进行分析，而不是对整个存储系统进行分析；为每个对象提供一致性保证，而不是为所有操作和/或对象提供一致性保证，这样开销要小得多。

在建立支撑其无数应用的存储系统时，商业网站将对高性能和可用性的需求放在首位。数据被复制，以抵御单个节点甚至整个数据中心的故障，无论是计划内的维护还是计划外的故障。事实上，新闻媒体上充斥着数据中心离线的例子，在这个过程中，整个网站都会瘫痪[26]。这种对可用性和性能的强烈关注--特别是当这些属性被编入严格的SLA要求时[4, 24]--导致许多商业系统牺牲了强大的一致性语义（如在谷歌[22]、亚马逊[15]、eBay[46]和Facebook[44] 等）。

最近，van Renesse和Schneider提出了一种用于对象存储的链式复制方法[47]，旨在提供强大的一致性并提高吞吐量。这种基本方法将所有存储对象的节点组织在一条链上，链尾处理所有的读请求，而链头处理所有的写请求。在客户端被确认之前，写会沿着链向下传播，因此在链尾提供了所有对象操作的简单排序，从而提供了强一致性。没有任何复杂的或多轮的协议，产生了简单性、良好的吞吐量和容易恢复。

不幸的是，基本的链式复制方法有一些限制。一个对象的所有读取都必须进入同一个节点，导致潜在的热点。为了更好地平衡负载，可以在一个节点集群中构建多个链--通过一致的散列[29]或更集中的目录方法[22]--但如果特定对象不成比例地受欢迎，这些算法仍然可能发现负载不平衡，这在实践中是一个真正的问题[17]。当试图在多个数据中心之间建立链时，也许会出现更严重的问题，因为对一个链的所有读取都可能由一个潜在的远程节点（链的尾部）处理。

本文介绍了CRAQ(Chain Replication with Apportioned Queries)的设计、实现和评估，这是一个对象存储系统，在保持链式复制的强大一致性属性[47]的同时，通过支持分摊查询，为读取操作提供更低的延迟和更高的吞吐量：也就是说，将读取操作分给链上的所有节点，而不是要求它们全部由一个主节点处理。本文的主要贡献有以下几点:

1. CRAQ使任何链上的节点都能处理读取操作，同时保持强一致性，从而支持在所有存储对象的节点上进行负载平衡。此外，当工作负载主要是读取时--这是其他系统中使用的假设，如谷歌文件系统[22]和Memcached[18]--CRAQ的性能可与只提供最终一致性的系统相媲美。
2. 除了强一致性之外，CRAQ的设计还自然地支持读操作之间的最终一致性，以便在写竞争期间进行低延迟读取，并在瞬时分区期间降级为只读行为。CRAQ允许应用程序指定读取操作可接受的最大滞后性。
3. 利用这些负载平衡特性，我们描述了一种广域系统设计，用于在不同地理区域的集群中建立CRAQ链，保留了强大的定位特性。具体来说，读取可以完全由本地集群处理，或者在最坏的情况下，需要在高写竞争期间在广域范围内传输简洁的元数据信息。我们还介绍了我们使用ZooKeeper[48]，一个类似PAXOS的组成员系统，来管理这些部署。

最后，我们讨论了CRAQ的额外扩展，包括为多对象原子更新整合迷你事务，以及使用组播来提高大对象更新的写入性能。不过，我们还没有完成这些优化的实现。

对CRAQ的初步性能评估表明，与基本的链式复制方法相比，它的吞吐量很高，对于以读为主的工作负载来说，它与链式节点的数量呈线性扩展：三节点链的吞吐量大约提高了200%，七节点链的吞吐量提高了600%。在高写入竞争期间，CRAQ在三节点链中的读取吞吐量比链式复制高出2倍，而且读取延迟仍然很低。我们描述了它在不同的工作负载和故障情况下的性能。最后，我们评估了CRAQ在地理复制存储方面的性能，显示出明显低于基本链式复制的延迟。

本文的其余部分组织如下。第2节提供了基本链复制和CRAQ协议之间的比较，以及CRAQ对最终一致性的支持。第3节描述了将CRAQ扩展到许多链，在数据中心内和跨数据中心，以及管理链和节点的组成员服务。第4节涉及到了多对象更新和利用组播等扩展。第5节描述了我们的CRAQ实现，第6节介绍了我们的性能评估，第7节回顾了相关工作，第8节是结论。

## 二、  基础系统模型

本节将介绍我们基于对象的接口和一致性模型，简要概述标准链式复制模型，然后介绍强一致性的 CRAQ 及其较弱的变体。

### 2.1 接口和一致性模型

一个基于对象的存储系统提供给用户两种原语：

- ***write(objID,V)***: 写（更新）操作将存储与对象标识符 objID 相关联的值 V。

- ***V ← read(objID)***: 读（查询）操作将与对象标识符 objID 相关联的值 V 取出。

考虑到各个独立的对象，我们将讨论两种主要的一致性：

- **强一致性**在本系统中保证了对一个对象的所有读写操作都按照一定的顺序执行，并且对一个对象的读取总是能看到最新写入的值。

- **最终一致性**在本系统中意味着对对象的写入仍会按顺序应用到所有节点上，但对不同节点的最终一致性读取可能会在不一致期间（即写操作被应用到所有节点之前）返回陈旧数据。但是，一旦所有副本都接收到写入，读取操作将不会返回比最新提交的写入更旧的版本。事实上，如果客户端与特定节点保持会话，也会看到单调的读取一致性（尽管在跨节点的会话中不是如此）。

接下来我们考虑链式复制和CRAQ是如何保证强一致性的。

### 2.2 链式复制
