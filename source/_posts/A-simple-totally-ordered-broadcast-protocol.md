---
title: A simple totally ordered broadcast protocol
date: 2023-02-01 14:22:00 +0800
categories: [Course,Paper]
tags: [distributed system,consensus algorithm,Zab]
---

# 一种简单的全序关系的广播协议

## 摘要

这是一个关于ZooKeeper使用的全序关系的广播协议的简短概述，称为Zab。它在概念上很容易理解，容易实现，而且性能高。在本文中，我们介绍了ZooKeeper对Zab的要求，展示了该协议的使用方法，并概述了该协议的工作方式。

<!-- more -->

## 一、  引言

在雅虎，我们开发了一个高性能的高可用协调服务，称为ZooKeeper[9]，允许大规模的应用程序执行协调任务，如领导者选举、状态传播和会合。这个服务实现了一个数据节点的分层空间，称为znodes，客户使用它来实现他们的协调任务。我们发现这项服务很灵活，其性能很容易满足我们在雅虎的网络规模、关键任务应用程序的生产需求。ZooKeeper放弃了锁，而是实现了无等待的共享数据对象，对这些对象的操作顺序有很强的保证。客户端库利用这些保证来实现他们的协调任务。一般来说，ZooKeeper的主要前提之一是更新顺序对应用程序来说比其他典型的协调技术（如阻塞）更重要。

嵌入ZooKeeper的是一个全序关系的广播协议： Zab。在实现我们的客户端保证时，有序的广播是至关重要的；在每个ZooKeeper服务器上维护ZooKeeper状态的副本也是必要的。这些副本使用我们的全序关系的广播协议保持一致，如复制的状态机[13]。本文主要介绍ZooKeeper对这个广播协议的要求以及对其实现的概述。

一个ZooKeeper服务通常由三到七台机器组成。我们的实现支持更多的机器，但三到七台机器提供了足够的性能和恢复力。客户端连接到任何一台提供服务的机器上，并始终对ZooKeeper的状态有一个一致的看法。该服务最多可以容忍f个崩溃故障，它至少需要2f+1个服务器。

应用程序广泛地使用ZooKeeper，并且有几十到几千个客户端同时访问它，所以我们需要高吞吐量。我们将ZooKeeper设计为读写操作比例高于2:1的工作负载；但是，我们发现ZooKeeper的高写吞吐量也允许它用于一些写为主的工作负载。ZooKeeper通过为每个服务器上的ZooKeeper状态的本地副本的读取提供服务来提供高的读取吞吐量。因此，容错性和读取吞吐量都可以通过增加服务器来扩展服务。写入吞吐量不会因为增加服务器而扩大；相反，它受限于广播协议的吞吐量，因此我们需要一个高吞吐量的广播协议。

![](figure01.jpg "Zookeeper服务组件")

<div style="text-align: center;"><b>图1</b>：Zookeeper服务的逻辑组件。</div>

图1显示了ZooKeeper服务的逻辑构成。读取请求是由包含ZooKeeper状态的本地数据库提供服务。写入请求从ZooKeeper请求转化为empotent事务，并在生成响应之前通过Zab发送。许多ZooKeeper的写请求在本质上是有条件的：一个znode只有在没有任何子节点的情况下才能被删除；一个znode在创建时可以附加一个名字和一个序列号；对数据的改变只有在它处于预期的版本时才会被应用。即使是无条件的写请求，也会以不等价的方式修改元数据，如版本号。

通过将所有的更新通过一台服务器（被称为领导者）发送，我们将非同位素的请求转化为同位素的事务。在本文中，我们使用术语事务来表示请求的空当性版本。领导可以进行转换，因为它对复制的数据库的未来状态有一个完美的看法，可以计算出新记录的状态。idempotent事务是这个新状态的记录。ZooKeeper在很多方面都利用了同位素事务，这不在本文的讨论范围之内，但是我们的事务的同位素性质也允许我们在恢复期间放松我们的广播协议的排序要求

## 二、  要求

我们假设有一组进程既实现了原子广播协议又使用了它。为了保证在ZooKeeper中正确地转化为empotent请求，每次都必须有一个领导者，所以我们通过协议的实现强制要求有一个这样的进程。我们在介绍协议的更多细节时，会更多地讨论它。
ZooKeeper对广播协议提出了以下要求：

**可靠的传递** 如果一个消息m被一个服务器传递，那么它最终会被所有正确的服务器传递。

**全序关系** 如果消息a在消息b之前被一台服务器传递，那么每台传递a和b的服务器都会在b之前传递a。

**因果顺序** 如果消息a在因果上先于消息b，并且两个消息都被送达，那么a必须在b之前排序。

为了保证正确性，ZooKeeper还要求有以下前缀属性：

**前缀属性**： 如果m是领导者L最后交付的消息，那么L在m之前提出的任何消息必须
也必须被传递；

请注意，一个进程可能被选举多次。但是，就这个前缀属性而言，每次都算作是一个不同的领导者。

有了这三个保证，我们就可以维护ZooKeeper数据库的正确副本：

1. 可靠性和总秩序保证确保所有的副本都有一个一致的状态；
2. 因果顺序保证复制体的状态从使用Zab的应用程序的角度来看是正确的；
3. 领导根据收到的请求向数据库提出更新。

值得注意的是，Zab考虑的因果关系有两种类型：

1. 如果两个消息，a和b，是由同一个服务器发送的，并且a在b之前被提出，我们说a在因果关系上先于b；
2. Zab假设每次只有一个领导者服务器可以提交提案。如果领导者发生变化，任何先前提议的消息都会因果地先于新领导者提议的消息。

我们的故障模型是有状态恢复的崩溃-故障。我们不假设同步时钟，但我们假设服务器对时间的感知速度大致相同。(我们使用超时来检测故障。)组成Zab的进程有持久的状态，所以进程可以在故障后重新启动并使用持久的状态来恢复。这意味着一个进程可能有部分有效的状态，比如缺少最近的事务，或者更有问题的是，该进程可能有先前从未交付的事务，现在必须被跳过。

我们规定要处理f故障，但我们也需要处理相关的可恢复故障，例如停电。为了从这些故障中恢复，我们要求在传递消息之前将消息记录在一个法定磁盘的磁盘介质上。(非常非技术性的、务实的、面向操作的原因使我们无法将UPS设备、冗余/专用网络设备和NVRAM等设备纳入我们的设计中)。

尽管我们没有假设拜占庭式故障，但我们确实使用摘要来检测数据损坏。我们还在协议包中添加了额外的元数据，并使用它们来检查是否正常。如果我们检测到数据损坏或理智性检查失败，我们将中止服务器进程。

操作环境和协议本身的独立实现的实际问题使得实现完全拜占庭容忍系统对我们的应用来说是不现实的。事实也表明，实现真正可靠的独立实现需要的不仅仅是编程资源[11]。到目前为止，我们的大多数生产问题要么是影响所有副本的实现错误，要么是在Zab的实现范围之外，但影响Zab的问题，如网络错误配置。

ZooKeeper使用内存数据库，并在磁盘上存储交易日志和定期快照。Zab的交易日志同时也是数据库的写前交易日志，因此一个交易只会被写到磁盘上一次。由于数据库是在内存中，而且我们使用千兆接口卡，所以瓶颈是写入时的磁盘I/O。为了缓解磁盘I/O的瓶颈，我们分批写入事务，这样我们就可以在一次写入磁盘中记录多个事务。这种批处理发生在副本上，而不是在协议层面上，所以这个实现更接近于数据库的分组提交[4, 6]，而不是消息打包[5]。我们选择不使用消息打包，以尽量减少延迟，同时仍然通过分批I/O到磁盘获得打包的大部分好处。

我们的崩溃-失败与状态恢复模型意味着，当服务器恢复时，它将读取其快照并重放该快照之后的所有已交付事务。因此，在恢复过程中，原子式广播不需要保证最多传递一次。我们使用idempotent事务意味着，只要在重启时保持秩序，一个事务的多次交付是可以的。这是对总秩序要求的放宽。具体来说，如果a在b之前被交付，在一次失败后a被重新交付，b也将在a之后被重新交付。

我们的其他性能要求是：

**低延迟**： ZooKeeper被应用程序广泛使用，我们的用户期待低响应时间。

**爆发式的高吞吐量**： 使用ZooKeeper的应用程序通常是以读为主的工作负载，但偶尔也会发生激进的重新配置，导致写入吞吐量的巨大峰值。

**平稳的故障处理**： 如果一个不是领导者的服务器发生故障，而仍然有一个正确的服务器的法定人数，应该不会出现服务中断的情况。

## 三、  为什么需要另一种协议