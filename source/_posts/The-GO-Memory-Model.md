---
title: The Go Memory Model
date: 2022-11-01 14:22:00 +0800
categories: [Course,Document]
tags: [programming language, go]
---

# Go内存模型
Version of June 6, 2022

## 介绍

Go 内存模型指定了以下条件,来保证在某一个goroutine中对一个变量进行读操作时,可以观察到在不同的GoRoutine中对该变量进行写操作产生的值。

<!-- more -->

### 建议
程序中改变的数据会被多个goroutine同时访问时,必须序列化此类访问。

若要序列化访问,请使用通道操作或其他同步原语保护数据,例如 sync 和 sync/atomic 中的那些。

如果你必须阅读本文档的其余部分才能了解你的程序的行为, 那你可太聪明了。

不要自作聪明。

### 非正式概述
Go 以与语言其他部分大致相同的方式处理其内存模型, 旨在保持语义简单、易懂和有用。 本节概述了该方法,对于大多数程序员来说应该足够了。 内存模型将在下一节中更正式地阐明。

数据竞争定义为在对内存某一位置写入时,同时发生了对同一位置的另一个读取或写入,除非涉及的所有访问都是 sync/atomic 包提供的原子数据访问。 如前所述,强烈建议程序员使用适当的同步 以避免数据竞争。 在没有数据竞争的情况下,Go 程序的行为就像所有的 goroutine 被多路复用到单个处理器上。

虽然程序员应该编写没有数据竞争的 Go 程序,Go 实现在响应数据竞争时可以做什么是有限制的。 实现可能始终通过报告争用和终止程序来响应数据争用。否则,每次读取单个字大小或子字大小的内存位置 必须观察实际写入该位置的值（可能是由并发执行的 goroutine） 并且尚未重写。 这些实现约束使 Go 更像 Java 或 JavaScript, 由于大多数竞争的结果有限, 不像 C 和 C++,其中任何带有竞争的程序的含义 完全未定义,编译器可能做出任何事情。 Go的方法旨在使错误的程序更可靠,更易于调试, 同时仍然坚持认为竞争是错误的,工具可以诊断和报告它们。

## 内存模型
以下 Go 内存模型的正式定义沿袭了 Hans-J. Boehm 和 Sarita V. Adve 发表于 PLDI 2008 的  “Foundations of the C++ Concurrency Memory Model”。data-race-free 程序的定义和race-free程序顺序一致性的保证与他们的这一作品中相同。

内存模型描述了程序执行的要求, 程序执行由 goroutine 执行组成, goroutine 执行又由内存操作组成。

内存操作由四个细节建模：

- 它的种类,表明它是普通数据读取,还是普通数据写入,或同步操作,例如原子数据访问, 互斥操作或通道操作,
- 它在程序中的位置,
- 正在访问的内存位置或变量,以及
- 该操作读取或写入的值。
  某些内存操作是类似读取的，包括读取、原子读取、互斥锁和通道接收。 其他内存操作类似写入，包括写入、原子写入、互斥解锁、通道发送和通道关闭。 有些，例如原子比较和交换，既是类似读的，也是类似写的。

goroutine执行被建模为由单个goroutine执行的一组内存操作。

**要求 1**： 每个goroutine中的内存操作必须对应于该goroutine的正确顺序执行，给定从内存中读出和写入的值。该执行必须符合先序关系，定义为Go语言规范为Go的控制流结构所规定的部分顺序要求，以及表达式的评估顺序。

**要求2**：对于一个给定的程序执行，映射W，当限于同步操作时，必须可以用一些隐含的同步操作的总顺序来解释，该顺序与排序和这些操作所读写的值一致。

如果一个同步的读类存储器操作r观察到一个同步的写类存储器操作w（也就是说，如果W(r)=w），那么w就同步于r。

发生在前的关系被定义为顺序在前和同步在前关系的联合的反式闭合。

**要求3**：对于一个内存位置x上的普通（非同步）数据读r，W(r)必须是一个对r可见的写w，其中可见意味着以下两个条件都成立。

1. w发生在r之前。
2. w不会发生在r之前发生的任何其他写w'（对x）之前。

内存位置x上的读写数据竞争由x上的读类内存操作r和x上的写类内存操作w组成，其中至少有一个是非同步的，这两个操作在发生之前是无序的（也就是说，r发生在w之前，w也没有发生在r之前）。

内存位置x上的写-写数据竞争由x上的两个类似写的内存操作w和w'组成，其中至少有一个是不同步的，它们在发生之前是无序的。

请注意，如果内存位置x上没有读写或写数据竞争，那么x上的任何读r只有一个可能的W(r)：在发生之前的顺序中紧接在它之前的单一w。

更一般地说，可以证明任何Go程序是 data-race-free的，也就是说，它没有存在读写数据竞争的程序执行，其结果只能由一些顺序一致的goroutine执行交错来解释。(证明方法与上文引用的Boehm和Adve的论文第7节相同。)这个属性被称为DRF-SC。

正式定义的意图是与其他语言（包括C、C++、Java、JavaScript、Rust和Swift）为race-free程序提供的DRF-SC保证相匹配。

Go语言的某些操作，如goroutine创建和内存分配，都是同步操作。这些操作对synchronized-before部分顺序的影响在下面的 "同步"部分有记录。各个包负责为自己的操作提供类似的文档。

## 包含数据竞争的程序的实现限制

上一节给出了data-race-free程序执行的正式定义。本节非正式地描述了实现必须为包含竞争的程序提供的语义。

首先，任何实现都可以在检测到数据竞争时，报告该竞争并停止程序的执行。使用ThreadSanitizer（通过 "go build -race "访问）的实现正是这样做的。

否则，对不大于一个机器字的内存位置x的读取必须观察到一些写w，使得r在w之前不会发生，并且没有写w'，使得w在w'之前发生，w'在r之前发生。

此外，不允许观察无因的和 "凭空 "的写入。

大于一个机器字的内存位置的读取被鼓励，但不需要满足与字大小的内存位置相同的语义，观察一个允许的写w。由于性能的原因，实现可以将更大的操作作为一组单独的机器字大小的操作，以一个未指定的顺序。这意味着多字数据结构上的竞争可能导致不一致的值，而不是对应于单一的写。当这些值依赖于内部（指针、长度）或（指针、类型）对的一致性时，如大多数Go实现中的接口值、map、切片和字符串，这种竞争又会导致任意的内存损坏。

下面的 "不正确的同步 "部分给出了不正确的同步的例子。

对实现的限制的例子在下面的 "不正确的编译"一节中给出。

## 同步

### 初始化
程序初始化在一个goroutine中运行，但这个goroutine可以创建其他goroutine，这些goroutine同时运行。

如果一个包p导入了包q，那么q的init函数的完成会在p的任何一个函数开始之前发生。

所有init函数的完成在函数main.main开始之前是同步的。

### 创建Goroutine
启动一个新的goroutine的go语句在goroutine的执行开始之前就已经同步了。

例如，在这个程序中
```
var a string

func f() {
	print(a)
}

func hello() {
	a = "hello, world"
	go f()
}
```
调用hello方法会在未来某个时间打印“hello world”（可能是在hello方法返回）。
### 销毁Goroutine
一个goroutine的退出并不保证在程序中的任何事件之前同步进行。例如，在这个程序中。
```
var a string

func hello() {
	go func() { a = "hello" }()
	print(a)
}
```
对a的赋值后面没有任何同步事件，所以它不能保证被其他goroutine观察到。事实上，一个积极的编译器可能会删除整个go语句。

如果一个goroutine的效果必须被另一个goroutine观察到，请使用同步机制，如锁或通道通信来建立一个相对顺序。
### 通道通信

通道通信是goroutine之间同步的主要方法。在一个特定通道上的每一个发送都与来自该通道的相应接收相匹配，通常是在一个不同的goroutine中。

在一个通道上的发送是在该通道的相应接收完成之前同步的。

这个程序:
```
var c = make(chan int, 10)
var a string

func f() {
	a = "hello, world"
	c <- 0
}

func main() {
	go f()
	<-c
	print(a)
}
```
保证打印 "hello, world"。对a的写排在了c的发送之前，c的发送在相应的接收完成之前进行同步，接收排在了打印之前。

关闭一个通道是在接收之前同步进行的，因为该通道已经关闭，所以返回一个零值。

在前面的例子中，用close(c)代替c <- 0，可以得到一个具有相同保证行为的程序。

从一个无缓冲通道的接收在该通道的相应发送完成之前被同步。

这个程序（同上，但发送和接收语句互换，并使用一个无缓冲的通道）：
```
var c = make(chan int)
var a string

func f() {
	a = "hello, world"
	<-c
}

func main() {
	go f()
	c <- 0
	print(a)
}
```
也保证了打印 "hello, world"。对a的写排在了c的发送之前，c的接收在相应的发送完成之前进行同步，而发送则排在了打印之前。

如果通道是缓冲的（例如，c = make(chan int, 1)），那么程序将不能保证打印 "hello, world"。(它可能会打印出空字符串，崩溃，或做其他事情）。

在一个容量为C的通道上的第k个接收是在该通道的第k+C个发送完成之前同步进行的。

这条规则将前面的规则概括为缓冲通道的规则。它允许用缓冲信道来模拟计数信号：信道中的项目数对应于有效使用的数量，信道的容量对应于同时使用的最大数量，发送一个项目会获得信号，而接收一个项目会释放信号。这是一个限制并发性的常见用法。

这个程序为工作列表中的每一个条目都启动了一个goroutine，但是这些goroutine使用限制通道进行协调，以确保一次最多有三个工作函数在运行。
```
var limit = make(chan int, 3)

func main() {
	for _, w := range work {
		go func(w func()) {
			limit <- 1
			w()
			<-limit
		}(w)
	}
	select{}
}
```

### 锁
sync包实现了两种锁的数据类型， sync.Mutex 和 sync.RWMutex.

对任何sync.Mutex 或 sync.RWMutex 变量 l 来说， n < m 时 ,在调用m次l.Lock() 返回前调用n次l.Unlock()总是同步的。

这个程序：
```
var l sync.Mutex
var a string

func f() {
	a = "hello, world"
	l.Unlock()
}

func main() {
	l.Lock()
	go f()
	l.Lock()
	print(a)
}
```
保证了打印 "hello, world"。对l.Unlock()的第一次调用（在f中）在对l.Lock()的第二次调用（在main中）返回之前是同步的，这是在打印之前的排序。

对于任何对sync.RWMutex变量l的调用l.RLock，有一个n，使得对l.Unlock的第n次调用在l.RLock的返回之前被同步，而对l.RUnlock的匹配调用在对l.Lock的调用n+1返回之前被同步。

对l.TryLock（或l.TryRLock）的成功调用等同于对l.Lock（或l.RLock）的调用。一个不成功的调用完全没有同步的效果。就内存模型而言，l.TryLock（或l.TryRLock）可以被认为是能够返回false的，即使是在互斥区l被解锁的情况下。
### Once
Sync包通过使用Once类型为存在多个goroutines的情况下的初始化提供了一种安全机制。多个线程可以为一个特定的f执行once.Do(f)，但只有一个线程会运行f()，其他调用会阻塞，直到f()返回。

从once.Do(f)中调用一次f()的完成是在任何调用once.Do(f)的返回之前同步进行的。

在这个程序中:
```
var a string
var once sync.Once

func setup() {
	a = "hello, world"
}

func doprint() {
	once.Do(setup)
	print(a)
}

func twoprint() {
	go doprint()
	go doprint()
}
```
调用twoprint将精确地调用setup一次。setup函数将在调用print之前完成。结果是，"hello, world "将被打印两次。

### 原子值
sync/atomic包中的API统称为 "原子操作"，可用于同步不同goroutines的执行。如果一个原子操作A的效果被原子操作B观察到，那么A就会在B之前被同步。一个程序中执行的所有原子操作的行为就像以某种顺序一致的方式执行。

前面的定义与C++的顺序一致的原子操作和Java的volatile变量的语义相同。

### 终结器
runtime包提供了一个SetFinalizer函数，该函数添加了一个终结器，当程序不再能到达某个特定对象时，就会调用这个终结器。对SetFinalizer(x, f)的调用在最终化调用f(x)之前是同步的。

### 额外机制
sync包提供了额外的同步抽象，包括条件变量、无锁映射、分配池和等待组。每个包的文档都说明了它对同步的保证。

其他提供同步抽象的包也应该在文档中记录它们的保证。

## 不正确的同步
有竞争的程序是不正确的，可以表现出非顺序一致的执行。特别是要注意的是，一个读r可能会观察到与r同时执行的任何写w所写的值。即使发生这种情况，也不意味着在r之后发生的读会观察到w之前发生的写。

在这个程序中：
```
var a, b int

func f() {
	a = 1
	b = 2
}

func g() {
	print(b)
	print(a)
}

func main() {
	go f()
	g()
}
```
有可能发生g打印出2，然后又打印出0。

这一事实使一些常见的用法失效了。

双重检查锁是为了避免同步化的开销。例如，twoprint程序可能被错误地写成：
```
var a string
var done bool

func setup() {
	a = "hello, world"
	done = true
}

func doprint() {
	if !done {
		once.Do(setup)
	}
	print(a)
}

func twoprint() {
	go doprint()
	go doprint()
}
```
但不能保证在doprint中，观察到对done的写意味着观察到对a的写。这个版本可以（不正确地）打印一个空字符串，而不是 "hello, world"。

另一个不正确的常见用法是忙于等待一个值，如：
```
var a string
var done bool

func setup() {
	a = "hello, world"
	done = true
}

func main() {
	go setup()
	for !done {
	}
	print(a)
}
```
如前所述，在main中，不能保证观察到写给done的内容就意味着观察到写给a的内容，所以这个程序也可以打印一个空字符串。更糟糕的是，由于两个线程之间没有同步事件，所以无法保证写给done的数据会被main观察到。main中的循环不能保证完成。

在这个主题上还有一些更微妙的变体，比如这个程序：
```
type T struct {
	msg string
}

var g *T

func setup() {
	t := new(T)
	t.msg = "hello, world"
	g = t
}

func main() {
	go setup()
	for g == nil {
	}
	print(g.msg)
}
```
即使main观察到g != nil并退出其循环，也不能保证它能观察到g.msg的初始化值。

在所有这些例子中，解决方案都是一样的：使用显式同步。

## 不正确的编译
Go的内存模型对编译器优化的限制和对Go程序的限制一样多。一些在单线程程序中有效的编译器优化在所有Go程序中都是无效的。特别是，编译器不能引入原程序中不存在的写，不能允许一个读来观察多个值，也不能允许一个写来写多个值。

下面所有的例子都假设`*p`和`*q`指的是多个goroutine可以访问的内存位置。

不在race-free程序中引入数据竞争意味着不将写操作从条件语句中移出，因为它们出现在条件语句中。例如，编译器不能在这个程序中倒置条件。
```
*p = 1
if cond {
	*p = 2
}
```
也就是说， 编译器不得将该程序改写成这个程序：
```
*p = 2
if !cond {
	*p = 1
}
```
如果cond值为false，另一个goroutine正在读取*p，那么在原来的程序中，另一个goroutine只能观察到*p的任何先前值和1。

不引入数据竞争也意味着不假定循环会终止。例如，一般来说，编译器不能把对*p或*q的访问移到这个程序中的循环前面：
```
n := 0
for e := list; e != nil; e = e.next {
	n++
}
i := *p
*q = 1
```
如果list指向一个循环列表，那么原程序永远不会访问*p或*q，但重写的程序会。(如果编译器能证明`*p`不会恐慌，那么将`*q`提前是安全的；将`*q`提前也需要编译器证明没有其他goroutine可以访问`*q`)。

不引入数据竞争也意味着不假设被调用的函数总是返回或没有同步操作。例如，编译器不能在这个程序中把对*p或*q的访问移到函数调用之前（至少在不直接了解f的精确行为的情况下不能这样做）：
```
f()
i := *p
*q = 1
```
如果该调用从未返回，那么原程序将再次无法访问*p或*q，但重写的程序可以。而如果调用包含同步操作，那么原程序可以在访问*p和*q之前的边上建立发生，但重写的程序不会。

不允许一次读取观察多个值意味着不允许从共享内存中重新加载局部变量。例如，在这个程序中，编译器不能丢弃i并第二次从*p重新加载它：
```
i := *p
if i < 0 || i >= len(funcs) {
	panic("invalid function index")
}
... complex code ...
// compiler must NOT reload i = *p here
funcs[i]()
```
如果复杂的代码需要很多寄存器，单线程程序的编译器可以丢弃i而不保存副本，然后在funcs\[i\]()之前重新加载i = *p。Go编译器则不能这样做，因为*p的值可能已经改变。(相反，编译器可以将i溢出到堆栈中）。

不允许一次写入多个值也意味着在写入前不使用将写入局部变量的内存作为临时存储。例如，在这个程序中，编译器不得使用*p作为临时存储。
```
*p = i + *p/2
```
也就是说， 编译器不得将该程序改写成这个程序：
```
*p /= 2
*p += i
```
如果i和*p开始等于2，原代码做*p=3，所以一个竞赛线程只能从*p中读取2或3。重写的代码先做*p=1，然后再做*p=3，这样一个竞赛线程也可以读到1。

请注意，所有这些优化在C/C++编译器中都是允许的：与C/C++编译器共享后端的Go编译器必须注意禁用那些对Go无效的优化。

请注意，如果编译器能够证明数据竞争不会影响目标平台上的正确执行，那么禁止引入数据竞争的规定就不适用。例如，在基本上所有的CPU上，改写以下内容是有效的：
```
n := 0
for i := 0; i < m; i++ {
	n += *shared
}
```
改写成：
```
n := 0
local := *shared
for i := 0; i < m; i++ {
	n += local
}
```
只要能证明*shared在访问时不会出错，因为可能增加的读不会影响任何现有的并发读或写。另一方面，这种重写在源到源的翻译器中是无效的。

## 结论
编写data-race-free的Go程序员可以依赖这些程序的顺序一致的执行，就像在基本上所有其他现代编程语言中一样。

当涉及到有竞争的程序时，程序员和编译器都应该记住一个建议：不要耍小聪明。
